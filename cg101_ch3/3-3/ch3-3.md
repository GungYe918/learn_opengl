# CH3 — Matrices as Transformations (2D first, then 4x4 intro)

## CH3-3. 행렬 곱은 변환의 합성이다: 손계산 예제 1개와 “순서가 왜 결과를 바꾸는가”의 정식 확인

### 1) 본 소제목의 학습 범위

본 소제목은 “행렬 곱 = 변환 합성”이라는 진술을 단순한 구호가 아니라, 실제 숫자 계산으로 검증되는 명제 형태로 확정한다. 이를 위해 2x2 또는 3x3 중 하나의 작은 예제를 선택해 손계산(hand-worked)으로 전개하고, 같은 변환을 다른 순서로 합성했을 때 결과가 달라짐을 수치로 확인한다. 본 소제목의 목적은 다음과 같다.

* (v' = (AB)v = A(Bv))의 의미를 계산으로 고정
* (AB \neq BA)의 구체적 예시 제시
* “순서 차이”가 단지 구현 관례가 아니라 정의 자체에서 발생함을 확인

---

### 2) Math Booster: 합성의 정의와 표기 규약

본 과정은 column vector 표기((v)를 열벡터로 두고, 변환을 왼쪽에서 곱함)를 기준으로 한다. 이때 변환 (A)와 (B)가 있을 때,

* “먼저 (B) 적용, 그 다음 (A) 적용”은
  [
  v' = A(Bv) = (AB)v
  ]
  로 표현된다.

즉, 행렬 곱 (AB)의 오른쪽에 있는 변환이 먼저 적용된다. 이는 단순한 약속이 아니라 “함수 합성”의 표준적 표기와 동일한 구조를 가진다.

---

### 3) 손계산 예제: 2D에서 회전과 비균등 스케일의 비가환성

#### 3.1 변환 정의

각도 (90^\circ) 회전 행렬 (R)을 다음으로 둔다.

[
R =
\begin{pmatrix}
0 & -1 \
1 & 0
\end{pmatrix}
]

비균등 스케일 (S)를 다음으로 둔다.

[
S =
\begin{pmatrix}
2 & 0 \
0 & 1
\end{pmatrix}
]

테스트 벡터 (v)는

[
v =
\begin{pmatrix}
1 \
1
\end{pmatrix}
]

로 둔다.

---

#### 3.2 순서 1: 먼저 스케일, 그 다음 회전

정의에 따라 “S 먼저, R 나중”은 (Rv' = R(Sv) = (RS)v)에 해당한다.

1. (Sv) 계산:
   [
   Sv =
   \begin{pmatrix}
   2 & 0 \
   0 & 1
   \end{pmatrix}
   \begin{pmatrix}
   1\
   1
   \end{pmatrix}
   =
   \begin{pmatrix}
   2\
   1
   \end{pmatrix}
   ]

2. (R(Sv)) 계산:
   [
   R
   \begin{pmatrix}
   2\
   1
   \end{pmatrix}
   =
   \begin{pmatrix}
   0 & -1 \
   1 & 0
   \end{pmatrix}
   \begin{pmatrix}
   2\
   1
   \end{pmatrix}
   =
   \begin{pmatrix}
   -1\
   2
   \end{pmatrix}
   ]

따라서
[
(RS)v =
\begin{pmatrix}
-1\
2
\end{pmatrix}
]

---

#### 3.3 순서 2: 먼저 회전, 그 다음 스케일

“R 먼저, S 나중”은 (S(Rv) = (SR)v)에 해당한다.

1. (Rv) 계산:
   [
   Rv =
   \begin{pmatrix}
   0 & -1 \
   1 & 0
   \end{pmatrix}
   \begin{pmatrix}
   1\
   1
   \end{pmatrix}
   =
   \begin{pmatrix}
   -1\
   1
   \end{pmatrix}
   ]

2. (S(Rv)) 계산:
   [
   S
   \begin{pmatrix}
   -1\
   1
   \end{pmatrix}
   =
   \begin{pmatrix}
   2 & 0 \
   0 & 1
   \end{pmatrix}
   \begin{pmatrix}
   -1\
   1
   \end{pmatrix}
   =
   \begin{pmatrix}
   -2\
   1
   \end{pmatrix}
   ]

따라서
[
(SR)v =
\begin{pmatrix}
-2\
1
\end{pmatrix}
]

---

#### 3.4 결론: (RS \neq SR)의 수치적 확정

동일한 (R, S, v)에 대해
[
(RS)v =
\begin{pmatrix}
-1\
2
\end{pmatrix},
\quad
(SR)v =
\begin{pmatrix}
-2\
1
\end{pmatrix}
]
이므로 결과가 다르다. 따라서

[
RS \neq SR
]

이 결론은 “행렬 곱은 일반적으로 교환법칙을 만족하지 않는다”는 진술을, 단일 반례로 완결된 논증 형태로 확정한다.

---

### 4) 왜 이런 일이 발생하는가: 해석의 최소 구조

비균등 스케일은 공간을 특정 축 방향으로 “늘이거나 줄이는” 변환이며, 회전은 축 자체의 방향을 바꾼다. 따라서

* 먼저 스케일을 적용하면 “원래 축 기준”으로 늘어난 후 회전한다.
* 먼저 회전을 적용하면 “회전된 축 기준”으로 스케일이 적용된다.

즉, 스케일이 참조하는 축이 회전에 의해 바뀌기 때문에 결과가 달라진다. 이는 좌표계 표현의 문제가 아니라, 변환 합성의 기하학적 성질이다.

---

### 5) OpenGL 실습과의 연결(개념적 연결만 수행)

CH3-1과 CH3-2에서 작성한 코드에서 다음 구문은 위 수학 정의를 그대로 구현한다.

* `glm::mat2 M1 = R * S;`
* `glm::mat2 M2 = S * R;`
* `glm::mat3 M  = T * R * S;`

그리고 Vertex Shader에서 `p' = M * p`는 (v' = Mv)의 정의를 그대로 수행한다. 즉, shader는 “행렬 곱의 의미”를 변경하지 않으며, 단지 그 계산을 GPU에서 수행한다.

---

### 6) Common pitfalls

* “(AB)에서 (A)가 먼저 적용된다”는 혼동이 매우 빈번하다. 본 과정의 표기 규약에서는 (AB)는 (B) 후 (A)이다. 혼동이 발생하면 (v' = A(Bv))를 반드시 괄호로 써서 확인한다.
* 회전 행렬의 부호(시계/반시계)는 좌표계 규약과 각도 정의에 의존한다. 본 소제목의 목적은 “순서가 중요함”의 확정이며, 부호의 방향은 후속 챕터에서 좌표계 규약과 함께 정리된다.