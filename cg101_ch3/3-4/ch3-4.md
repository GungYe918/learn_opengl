[OPENGL_CG101_PROGRESS] current_chapter=3, completed=[1,2], next_up=Chapter 3-4 (from 3x3 2D to 4x4 3D: homogeneous coordinates generalization; what a 4x4 does)

# CH3 — Matrices as Transformations (2D first, then 4x4 intro)

## CH3-4. 3x3(2D)에서 4x4(3D)로의 일반화: homogeneous coordinates의 확장과 “4x4가 담당하는 역할”의 명세

### 1) 본 소제목의 학습 범위

본 소제목은 CH3-2에서 도입한 homogeneous coordinates를 3D로 확장하여, 왜 graphics에서 사실상 표준이 4x4인지(즉, 왜 3D에서도 3x3이 아니라 4x4를 쓰는지)를 정의 수준에서 확정한다. OpenGL 코드 실습은 필수 범위가 아니며, 개념 정의와 행렬 구조의 명세가 목적이다. 다루는 항목은 다음으로 한정한다.

* 3D에서 선형변환(3x3)과 affine transform(4x4)의 구분
* 3D homogeneous coordinates: point와 direction의 (w) 구분
* 4x4 행렬이 “회전/스케일 + translation”을 하나의 곱으로 통일하는 방식
* 4x4의 마지막 행/열이 수행하는 역할에 대한 최소 설명(원리 수준)

본 소제목에서는 perspective projection은 다루지 않는다. perspective divide 및 clip-space는 CH4에서 정식 도입한다.

---

### 2) Math Booster: 3D에서의 선형변환과 affine transform

#### 2.1 3D 선형변환은 3x3으로 충분하다

3D vector (\vec{v}=(x,y,z))에 대한 선형변환은 다음과 같이 표현된다.

[
\vec{v}' = A\vec{v},\quad A\in\mathbb{R}^{3\times 3}
]

여기서 (A)는 회전(rotation), 스케일(scaling), 쉬어(shear) 등을 포함한다. 그러나 translation은 여전히 선형이 아니며, 3x3에 포함되지 않는다.

#### 2.2 3D affine transform의 표준 형태

translation (\vec{t}=(t_x,t_y,t_z))를 포함하면 변환은 다음 형태가 된다.

[
F(\vec{v}) = A\vec{v} + \vec{t}
]

CH3-2와 동일한 논리로, 상수항 (\vec{t}) 때문에 (F(\vec{0})=\vec{t}\neq \vec{0})이 되어 선형성이 깨진다.

---

### 3) 3D homogeneous coordinates: (x,y,z)을 (x,y,z,w)로 확장

#### 3.1 point와 direction의 명세

3D에서도 동일한 규약이 유지된다.

* point(위치):
  [
  \tilde{p}=
  \begin{pmatrix}
  x\y\z\1
  \end{pmatrix}
  ]
* direction(방향):
  [
  \tilde{d}=
  \begin{pmatrix}
  x\y\z\0
  \end{pmatrix}
  ]

이 구분은 “translation은 점에는 작용하지만 방향에는 작용하지 않는다”는 기하학적 의미를 행렬 곱 내부에서 보존한다.

---

### 4) 4x4 affine transform 행렬의 표준 형태

3D affine transform (F(\vec{v})=A\vec{v}+\vec{t})는 다음 4x4로 표현된다.

[
M=
\begin{pmatrix}
a_{00}&a_{01}&a_{02}&t_x\
a_{10}&a_{11}&a_{12}&t_y\
a_{20}&a_{21}&a_{22}&t_z\
0&0&0&1
\end{pmatrix}
]

그리고

[
\tilde{p}' = M\tilde{p}
]

를 계산하면 결과의 앞 3개 성분이 (A\vec{p}+\vec{t})로 정리되고, 마지막 성분은 1이 유지된다.

#### 4.1 direction에 대한 translation 불작용의 정식 확인

(\tilde{d}=(x,y,z,0)^T)에 대해

[
M\tilde{d}=
\begin{pmatrix}
A\vec{d}\
0
\end{pmatrix}
]

이므로 translation은 제거된다. 따라서 4x4는 point와 direction을 동일한 연산 (M\cdot) 형태로 처리하면서도 의미를 분리한다.

---

### 5) “4x4를 쓰는 이유”의 구조적 결론

graphics에서 4x4가 표준이 되는 이유는 다음의 제약을 동시에 만족시키기 위해서이다.

1. 회전/스케일/쉬어(선형)와 translation(비선형)을 하나의 행렬 곱으로 통일
2. 변환 합성(composition)을 행렬 곱 하나로 닫힘(closed) 있게 유지
3. point와 direction의 의미 차이를 (w=1), (w=0) 규약으로 동일 파이프라인에서 처리
4. 이후 CH4에서 도입될 perspective projection 또한 동일한 4x4 틀에서 기술 가능

즉, 4x4는 “3D 공간을 4D로 올려서 표현을 통일하는 장치”이며, 이 통일성이 GPU 파이프라인에서 자료 전달 및 합성 설계를 단순화한다.

---

### 6) OpenGL에서의 관찰 포인트(개념 수준)

Vertex Shader의 전형적인 형태는 다음과 같이 요약된다.

* 입력: `vec3 aPos`
* 확장: `vec4(aPos, 1.0)`
* 변환: `mat4 M * vec4(...)`
* 출력: `gl_Position = ...`

이 구조는 CH3-2의 `mat3 * vec3(x,y,1)`을 3D로 확장한 것이다. 본 소제목의 결론은 “OpenGL이 4x4를 강요해서가 아니라, 3D affine(+projection) 표현을 행렬 곱 하나로 통일하기 위해 4x4가 자연스럽게 표준화된다”는 점이다.

---

### 7) Common pitfalls

* 4x4를 “3D보다 한 차원 더 높은 공간으로 실제 이동한다”고 오해하는 경우가 있다. 동차좌표는 표현 기법이며, 목적은 affine 및 이후 projection을 동일한 곱으로 기술하기 위함이다.
* (w=0)을 임의로 사용하면 translation이 제거되어, 위치를 변환하려는 의도와 충돌한다. (w)는 데이터의 의미를 나타내는 규약이다.