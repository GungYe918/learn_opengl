[OPENGL_CG101_PROGRESS] current_chapter=3, completed=[1,2], next_up=Chapter 3-2 (why translation isn’t linear; homogeneous coords via 3x3 in 2D; bridge to 4x4)

# CH3 — Matrices as Transformations (2D first, then 4x4 intro)

## CH3-2. translation은 왜 `mat2`로 표현되지 않는가: affine transform과 homogeneous coordinates(2D에서 3x3)

### 1) 본 소제목의 학습 범위

본 소제목은 CH3-1에서 의도적으로 배제했던 translation을 “같은 수학 체계”로 편입시키기 위해 필요한 개념을 정식화한다. 핵심은 다음 두 문장으로 요약된다.

* translation은 선형변환이 아니며, 따라서 2x2 행렬(`mat2`)만으로는 표현할 수 없다.
* translation을 포함한 affine transform을 행렬 곱으로 일관되게 다루기 위해 homogeneous coordinates(동차좌표)를 도입한다.

본 소제목은 2D에서 3x3을 먼저 도입하여 개념을 고정하고, 다음 소제목/챕터에서 3D의 4x4로 자연스럽게 확장되도록 구성한다.

---

### 2) Math Booster: 선형변환 vs affine transform

#### 2.1 translation이 선형변환이 아닌 이유(정의 기반)

선형변환 (T)는 반드시
[
T(\vec{0}) = \vec{0}
]
을 만족한다. 이는 선형성 조건에서 즉시 따라온다.

* (T(\vec{0}) = T(0\cdot \vec{v}) = 0\cdot T(\vec{v}) = \vec{0})

그러나 translation (t)를 더하는 변환
[
F(\vec{v}) = \vec{v} + \vec{t}
]
에 대해
[
F(\vec{0}) = \vec{t} \neq \vec{0}
]
이므로 (F)는 선형변환이 아니다. 이 결론은 “2x2로는 절대 못 한다”는 주장에 대한 정의 수준의 근거가 된다.

#### 2.2 affine transform의 표준 형태

translation을 포함한 2D 변환은 보통 다음 형태로 기술된다.

[
F(\vec{v}) = A\vec{v} + \vec{t}
]

* (A): 2x2 선형 부분(회전/스케일/쉬어 등)
* (\vec{t}): translation

이 형태는 “선형 + 상수항”이며, 이 상수항 때문에 선형성이 깨진다. 문제는 실무에서 변환을 여러 개 이어 붙일 때인데, 이때 (A\vec{v}+\vec{t}) 형태는 조합이 번거롭고, 특히 GPU에서는 변환을 **행렬 곱 하나로 통일**해 전달하는 것이 자연스럽다. 그 통일 장치가 homogeneous coordinates이다.

---

### 3) homogeneous coordinates(동차좌표)의 도입: 2D를 3D로 “들어 올리기”

2D vector ((x,y))를 동차좌표로 확장하면 다음과 같이 표현한다.

* point(위치):
  [
  \tilde{p} = \begin{pmatrix} x \ y \ 1 \end{pmatrix}
  ]
* direction(방향):
  [
  \tilde{d} = \begin{pmatrix} x \ y \ 0 \end{pmatrix}
  ]

여기서 마지막 성분 (w)의 역할은 결정적이다.

* (w=1): translation의 영향을 받는 “점”
* (w=0): translation의 영향을 받지 않는 “방향”

이 구분은 CH2에서 확립한 point vs direction의 개념을, 행렬 체계 안에서 엄밀히 유지하는 메커니즘으로 작동한다.

---

### 4) 2D affine transform을 3x3 행렬로 표현

#### 4.1 행렬 형태

선형 부분 (A)와 translation (\vec{t}=(t_x,t_y))를 포함한 2D affine transform은 다음 3x3으로 표현된다.

[
M =
\begin{pmatrix}
a_{00} & a_{01} & t_x \
a_{10} & a_{11} & t_y \
0      & 0      & 1
\end{pmatrix}
]

점 (\tilde{p}=(x,y,1)^T)에 대해

[
\tilde{p}' = M\tilde{p}
]

를 계산하면

[
\begin{pmatrix}
x'\y'\1
\end{pmatrix}
=============

\begin{pmatrix}
a_{00}x + a_{01}y + t_x \
a_{10}x + a_{11}y + t_y \
1
\end{pmatrix}
]

즉, (A\vec{v}+\vec{t})가 행렬 곱 하나로 구현된다.

#### 4.2 direction이 translation에 영향을 받지 않는 이유(정식 확인)

direction (\tilde{d}=(x,y,0)^T)에 대해 동일한 (M)을 곱하면

[
M\tilde{d} =
\begin{pmatrix}
a_{00}x + a_{01}y + t_x\cdot 0 \
a_{10}x + a_{11}y + t_y\cdot 0 \
0
\end{pmatrix}
=============

\begin{pmatrix}
A\vec{d}\0
\end{pmatrix}
]

translation이 사라진다. 따라서 동차좌표는 “점과 방향을 동일한 데이터 구조로 보내되, 의미를 보존하는 방식”으로 작동한다.

---

### 5) OpenGL 실습: `mat3`로 2D affine transform 적용 (translation 포함)

CH3-1 코드를 기반으로, `mat2`를 `mat3`로 확장하고, 입력 정점을 동차좌표로 들어 올려 변환을 적용한다.

#### 5.1 Vertex Shader 핵심 변경

* 입력: `vec2 aPos`
* 확장: `vec3(aPos, 1.0)`
* 변환: `uM * vec3(...)`
* 출력: 결과의 xy를 사용

#### 5.2 파일: `main.cpp` (CH3-1과 독립적으로 동작하도록 완결 구성)

```cpp
// src/main.cpp
#include <cstdio>
#include <cmath>

#include <glad/glad.h>
#include <GLFW/glfw3.h>

#include <glm/glm.hpp>
#include <glm/gtc/type_ptr.hpp>


static void framebuffer_size_callback(GLFWwindow* window, int w, int h) {
    glViewport(0, 0, w, h);
}

static GLuint compileShader(GLenum type, const char* src) {
    GLuint sh = glCreateShader(type);
    glShaderSource(sh, 1, &src, nullptr);
    glCompileShader(sh);

    GLint ok = 0;
    glGetShaderiv(sh, GL_COMPILE_STATUS, &ok);
    if (!ok) {
        char log[1024];
        glGetShaderInfoLog(sh, 1024, nullptr, log);
        std::fprintf(stderr, "Shader compile error:\n%s\n", log);
    }

    return sh;
}

static GLuint makeProgram(const char* vsSrc, const char* fsSrc) {
    GLuint vs = compileShader(GL_VERTEX_SHADER, vsSrc);
    GLuint fs = compileShader(GL_FRAGMENT_SHADER, fsSrc);

    GLuint prog = glCreateProgram();
    glAttachShader(prog, vs);
    glAttachShader(prog, fs);
    glLinkProgram(prog);

    GLint ok = 0;
    glGetProgramiv(prog, GL_LINK_STATUS, &ok);
    if (!ok) {
        char log[1024];
        glGetProgramInfoLog(prog, 1024, nullptr, log);
        std::fprintf(stderr, "Program link error:\n%s\n", log);
    }

    glDeleteShader(vs);
    glDeleteShader(fs);
    return prog;
}


int main() {
    if (!glfwInit()) {
        std::fprintf(stderr, "glfwInit failed!\n");
        exit(1);
    }

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    GLFWwindow* window = glfwCreateWindow(800, 600, "CG101 CH3-2: mat3 affine (2D)", nullptr, nullptr);
    if (!window) {
        std::fprintf(stderr, "glfwCreateWindow failed!\n");
        exit(1);
    }
    glfwMakeContextCurrent(window);
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        std::fprintf(stderr, "gladLoadGLLoader failed!\n");
        glfwDestroyWindow(window);
        glfwTerminate();
        exit(1);
    }

    const char* vsSrc = R"GLSL(
        #version 330 core
        layout (location = 0) in vec2 aPos;

        uniform mat3 uM; // 2D affine transform in homogeneous coordinates

        void main() {
            vec3 p  = vec3(aPos, 1.0); // point: w=1
            vec3 tp = uM * p;          // transformed homogeneous point
            gl_Position = vec4(tp.xy, 0.0, 1.0);
        }
    )GLSL";

    const char* fsSrc = R"GLSL(
        #version 330 core
        out vec4 FragColor;
        void main() {
            FragColor = vec4(0.95, 0.65, 0.20, 1.0);
        }
    )GLSL";

    GLuint program = makeProgram(vsSrc, fsSrc);

    const float verts[] = {
        -0.5f, -0.5f,
         0.5f, -0.5f,
         0.0f,  0.5f
    };

    GLuint vao = 0;
    GLuint vbo = 0;
    glGenVertexArrays(1, &vao);
    glGenBuffers(1, &vbo);

    glBindVertexArray(vao);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferData(GL_ARRAY_BUFFER, sizeof(verts), verts, GL_STATIC_DRAW);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    glBindVertexArray(0);

    // --- Build 2D affine matrix M (mat3) ---
    // compose: M = T * R * S  (apply S, then R, then T to points)
    float deg = 25.0f;
    float rad = deg * (3.14159265358979323846f / 180.0f);
    float c = std::cos(rad);
    float s = std::sin(rad);

    // 2D scale (as 3x3)
    glm::mat3 S(
        1.3f, 0.0f, 0.0f,
        0.0f, 0.9f, 0.0f,
        0.0f, 0.0f, 1.0f
    );

    // 2D rotation (as 3x3)
    glm::mat3 R(
        c,   -s,  0.0f,
        s,    c,  0.0f,
        0.0f, 0.0f, 1.0f
    );

    // 2D translation (as 3x3)
    float tx = 0.25f;
    float ty = 0.10f;
    glm::mat3 T(
        1.0f, 0.0f, tx,
        0.0f, 1.0f, ty,
        0.0f, 0.0f, 1.0f
    );

    glm::mat3 M = T * R * s;

    glUseProgram(program);
    GLint locM = glGetUniformLocation(program, "uM");
    glUniformMatrix3fv(locM, 1, GL_FALSE, glm::value_ptr(M));

    while (!glfwWindowShouldClose(window)) {
        if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
            glfwSetWindowShouldClose(window, true);

        glClearColor(0.07f, 0.07f, 0.09f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        glUseProgram(program);
        glBindVertexArray(vao);
        glDrawArrays(GL_TRIANGLES, 0, 3);

        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    glDeleteVertexArrays(1, &vao);
    glDeleteBuffers(1, &vbo);
    glDeleteProgram(program);

    glfwDestroyWindow(window);
    glfwTerminate();
    return 0;
}
```

---

### 6) 실습에서 “정확히 확인해야 하는 사실”

1. `mat2`로는 translation이 불가능하며, `mat3`에 `w=1`을 가진 점을 곱하면 translation이 구현된다.
2. `T * R * S`는 “S 먼저, 그 다음 R, 마지막 T”를 의미한다. 이는 column vector 관례에서 합성의 정의에 의해 고정된다.
3. 점(point)은 (w=1)이므로 translation 영향을 받지만, 방향(direction)은 (w=0)이면 translation 영향을 받지 않는다(이 소제목의 핵심 원리).

---

## 7) Common pitfalls & debugging tips

* `T` 행렬의 translation 성분을 잘못된 위치에 넣는 실수가 흔하다. 본 소제목의 정의는 “마지막 열에 (t_x, t_y)” 형태이며, Vertex Shader는 `uM * vec3(x,y,1)`를 전제로 한다.
* `w=0`으로 바꾸었는데 triangle이 이동하지 않는 것은 버그가 아니라 동차좌표 정의의 직접 결과이다.
* 합성 순서를 바꾸면 결과가 달라지는 현상은 오류가 아니라 “정의가 바뀐 것”이다. 관찰된 결과를 정의로 환원해 설명할 수 있어야 한다.