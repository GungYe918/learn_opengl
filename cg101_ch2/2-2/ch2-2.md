[OPENGL_CG101_PROGRESS] current_chapter=2, completed=[1], next_up=Chapter 2-2 (dot product: angle/projection, “facing” tests)

# CH2 — Vectors: dot/cross, directions, normals (No matrices yet)

## CH2-2. dot product(내적): 각도, 정렬(alignment), projection의 정량화

### 1) 본 소제목의 학습 범위

본 소제목은 vector 사이의 관계를 “숫자 하나”로 요약하는 연산인 dot product(내적)를 정의하고, 그 값이 의미하는 바를 graphics 관점에서 엄밀히 고정한다. matrix 및 좌표계 변환은 다루지 않는다. 다루는 항목은 다음으로 한정한다.

* dot product(내적)의 대수적 정의와 기하학적 정의의 동치
* unit vector 전제에서 내적이 “cos(θ)”로 해석되는 조건
* projection(사영)의 스칼라/벡터 형태
* graphics에서의 표준적 사용 패턴(“facing test”, diffuse의 전제)

---

### 2) dot product(내적)의 정의

#### 2.1 대수적 정의 (component form)

2D에서 (\vec{a}=(a_x,a_y)), (\vec{b}=(b_x,b_y))일 때

$$
\vec{a}\cdot\vec{b} = a_x b_x + a_y b_y
$$

3D에서는

$$
\vec{a}\cdot\vec{b} = a_x b_x + a_y b_y + a_z b_z
$$

이 정의는 구현 관점에서 “성분별 곱의 합”이라는 완전히 결정적인 연산 규칙을 제공한다.

#### 2.2 기하학적 정의 (angle form)

(\theta)를 (\vec{a})와 (\vec{b}) 사이의 각(angle)이라 할 때, 다음이 성립한다.

$$
\vec{a}\cdot\vec{b} = |\vec{a}|,|\vec{b}|,\cos\theta
$$

이 식은 내적이 “두 벡터가 얼마나 같은 방향을 향하는지”를 길이와 함께 반영하는 값임을 의미한다.

---

### 3) 내적 값의 부호와 크기가 의미하는 것

#### 3.1 부호(sign)

$$
\vec{a}\cdot\vec{b} = |\vec{a}|,|\vec{b}|,\cos\theta
$$
에서 (\cos\theta)의 부호가 곧 내적의 부호를 결정한다.

* (\vec{a}\cdot\vec{b} > 0): (\theta \in (0^\circ, 90^\circ)) 범위, 대체로 “같은 방향 성분이 있음”
* (\vec{a}\cdot\vec{b} = 0): (\theta = 90^\circ), 직교(orthogonal)
* (\vec{a}\cdot\vec{b} < 0): (\theta \in (90^\circ, 180^\circ)), “반대 방향 성분이 있음”

이 부호 규칙은 graphics에서 “facing test”로 바로 사용된다. 예를 들어 어떤 표면의 normal (\vec{n})과 어떤 방향 (\vec{d})가 있을 때, (\vec{n}\cdot\vec{d})의 부호는 “표면이 그 방향을 향하고 있는가”를 판정하는 최소 조건이 된다.

#### 3.2 unit vector 전제의 중요성

두 벡터를 unit vector (\hat{a}, \hat{b})로 정규화했다면

$$
\hat{a}\cdot\hat{b} = \cos\theta
$$

즉, 내적이 “각도 정보만”을 담는 순수한 값이 된다. 반대로 정규화하지 않으면 내적은 (|\vec{a}||\vec{b}|)라는 크기 요소를 포함하므로, “각도 + 크기”의 혼합치가 된다. lighting 등에서 각도만 필요할 때 정규화가 필수인 이유가 여기에 있다.

---

### 4) projection(사영): “한 방향으로의 성분”을 뽑아내는 방식

#### 4.1 스칼라 projection (길이 성분)

(\vec{b}) 방향(단, (\vec{b}\neq\vec{0}))으로 (\vec{a})를 사영한 스칼라 성분은 다음으로 정의된다.

$$
\text{comp}_{\vec{b}}(\vec{a}) = \frac{\vec{a}\cdot\vec{b}}{|\vec{b}|}
$$

특히 (\hat{b})가 unit vector라면

$$
\text{comp}_{\hat{b}}(\vec{a}) = \vec{a}\cdot\hat{b}
$$

즉, “특정 방향으로의 길이 성분”을 내적 하나로 바로 얻는다.

#### 4.2 벡터 projection (방향 포함)

벡터 형태의 사영은 다음과 같다.

$$
\text{proj}_{\vec{b}}(\vec{a}) = \left(\frac{\vec{a}\cdot\vec{b}}{|\vec{b}|^2}\right)\vec{b}
$$

(\hat{b})가 unit vector이면

$$
\text{proj}_{\hat{b}}(\vec{a}) = (\vec{a}\cdot\hat{b})\hat{b}
$$

이 식은 “내적은 방향 정렬 정도를 측정하고, 그 값을 다시 그 방향으로 되돌려서 벡터로 만든다”는 구조를 갖는다.

---

### 5) graphics에서의 표준 사용 패턴 (개념 수준)

#### 5.1 facing test (전방/후방 판정)

어떤 표면의 normal (\hat{n})과, 표면에서 광원 방향(또는 시선 방향) (\hat{d})가 있을 때

* (\hat{n}\cdot\hat{d} > 0)이면 “대체로 같은 반구(hemisphere)에 있다”는 의미를 갖는다.
* (\hat{n}\cdot\hat{d} \le 0)이면 “반대편이다”에 해당하며, diffuse(난반사) 기여가 0으로 clamp되는 구조가 자연스럽게 도출된다.

이 내용은 CH7에서 조명 모델을 구축할 때 엄밀한 식으로 재등장한다.

#### 5.2 angle을 직접 구하는 것은 보통 최후 수단

각도 자체가 필요하면
$$
\theta = \arccos(\hat{a}\cdot\hat{b})
$$
이지만, graphics에서는 (\arccos)가 비용이 크고(또는 불필요한 경우가 많고) 수치 안정성 이슈도 있어 “내적 값 자체”를 직접 사용하는 경우가 대부분이다.

---

### 6) 실습 코드: dot product와 cos(θ) 확인

```cpp
#include <cmath>
#include <iostream>

struct Vec2 {
    float x, y;
};

static float dot(Vec2 a, Vec2 b) {
    return a.x*b.x + a.y*b.y;
}

static float length(Vec2 v) {
    return std::sqrt(dot(v, v));
}

static Vec2 normalize(Vec2 v) {
    float len = length(v);
    if (len == 0.0f) return { 0.0f, 0.0f };
    return { v.x/len, v.y/len };
}

static float clamp(float x, float lo, float hi) {
    return (x < lo) ? lo : (x > hi) ? hi : x;
}


int main() {
    Vec2 a { 1.0f, 0.0f };
    Vec2 b { 1.0f, 1.0f };

    Vec2 ah = normalize(a);
    Vec2 bh = normalize(b);

    float c = dot(ah, bh);      // = cos(theata)
    c = clamp(c, -1.0f, 1.0f);
    float theta = std::acos(c); // radians

    std::printf("cos(theta)=%.6f\n", c);
    std::printf("theta(rad)=%.6f, theta(deg)=%.3f\n", theta, theta * 180 / 3.141592653589793);

    return 0;
}
```

이 예시에서 기대되는 개념적 결론은 다음과 같다.

* (a=(1,0))과 (b=(1,1))의 각은 (45^\circ)이며, (\cos\theta \approx 0.7071)이 도출된다.
* 정규화가 없다면 내적은 (|\vec{a}||\vec{b}|\cos\theta)가 되어 “각도만”을 의미하지 않는다.

---

### 8) Common pitfalls 및 디버깅 포인트

* **정규화 누락**: 내적을 각도 의미로 쓰려면 입력을 unit vector로 정규화해야 한다는 조건이 누락되는 경우가 가장 흔하다.
* **0 vector 정규화**: 길이가 0인 vector는 정규화가 정의되지 않으며, NaN이 퍼지는 주요 원인이 된다.
* **acos 입력 범위**: 부동소수 오차로 내적 값이 ([-1,1])을 약간 벗어나면 `acos`가 NaN을 반환한다. clamp가 필요하다.
* **각도를 “필수로” 구하려는 습관**: 많은 그래픽 연산은 각도 자체가 아니라 (\cos\theta)만으로 충분하며, 내적 값 자체가 그 역할을 수행한다.