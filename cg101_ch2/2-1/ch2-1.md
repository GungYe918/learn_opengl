# CH2 — Vectors: dot/cross, directions, normals (No matrices yet)

## CH2-1. Vector를 “방향과 크기”로 다루는 방법: length, normalization, direction

### 1) 본 소제목의 학습 범위

본 소제목은 graphics에서 가장 자주 등장하는 데이터 타입인 **vector**를 “점(point)”이 아니라 “방향(direction) + 크기(magnitude)”로 해석하는 관점을 확립한다. 이 단계에서는 matrix, transformation, coordinate system chain을 도입하지 않는다. 다루는 항목은 다음으로 한정한다.

* vector의 의미(점 vs 방향)의 구분
* length(=norm)의 정의와 계산
* normalization의 의미와 필요성
* direction vector를 이용한 사고 방식(“어디로 향하는가”를 수치로 표현)

---

### 2) Vector의 역할: 점(point)과 방향(direction)의 구분

vector는 수학적으로 “성분들의 묶음”이지만, graphics에서는 용도가 명확히 분리된다.

* **point**: “공간에서의 위치”를 나타내는 값
  ex: 화면이나 월드에서의 좌표(이 챕터에서는 아직 월드/화면 체인을 엄밀히 다루지 않음)

* **direction vector**: “어느 방향으로 얼마나 가는가”를 나타내는 값
  ex: velocity, light direction, view direction, normal 등

중요한 실무적 구분은 다음과 같이 서술된다.

* point는 “절대적 위치”를 의미하므로, 다른 point와의 차이를 취할 때에만 방향이 드러난다.
  즉, 두 점 (A), (B)가 있을 때
  $$
  \vec{d} = B - A
  $$
  는 “A에서 B로 향하는 direction vector”이다.

* direction vector는 그 자체가 위치가 아니라 “변위(displacement)”로 해석된다.
  따라서 어떤 point (P)에서 방향 (\vec{v})로 이동하면
  $$
  P' = P + \vec{v}
  $$
  와 같이 기술된다.

이 구분은 이후 lighting에서 normal과 light direction을 다룰 때, 그리고 camera의 view direction을 다룰 때 핵심 전제가 된다.

---

### 3) Math Booster: length(=norm)의 정의와 직관

2D vector (\vec{v} = (x, y))의 length는 피타고라스 정리에 의해 다음으로 정의된다.

$$
|\vec{v}| = \sqrt{x^2 + y^2}
$$

3D vector (\vec{v} = (x, y, z))는

$$
|\vec{v}| = \sqrt{x^2 + y^2 + z^2}
$$

이 정의는 “vector를 원점에서 해당 점까지의 화살표로 놓고 보았을 때, 화살표의 길이”라는 기하학적 의미를 갖는다. graphics에서 length는 다음과 같은 형태로 직접 사용된다.

* 거리(distance): 두 point 차이의 length
  $$
  \text{distance}(A,B) = |B-A|
  $$
* 속력(speed): velocity vector의 length
  $$
  \text{speed} = |\vec{v}|
  $$

여기서 중요한 관찰은 “방향만 필요한 상황”과 “크기까지 필요한 상황”이 명확히 다르다는 점이다. 예를 들어 light direction은 보통 “방향만” 의미가 있으며, 거리 정보를 섞어 넣으면 shading이 왜곡된다.

---

### 4) Math Booster: normalization의 정의와 왜 필요한가

**normalization**은 “길이를 1로 만드는 연산”이다. 길이가 0이 아닌 vector (\vec{v})에 대해

$$
\hat{v} = \frac{\vec{v}}{|\vec{v}|}
$$

이때 (|\hat{v}| = 1) 이며, (\hat{v})는 **unit vector**라 부른다.

graphics에서 normalization이 중요한 이유는 다음 한 문장으로 정리된다.

* 많은 연산(특히 dot product 기반 연산)은 입력이 unit vector일 때 의미가 “각도”로 정규화되어 해석되며, 길이가 섞이면 결과가 크기와 각도의 혼합치가 된다.

예시적으로, 어떤 방향성을 “각도 정보”로만 사용하려면 길이가 통제되어 있어야 한다. 그렇지 않으면 같은 방향이라도 길이에 따라 계산 결과가 달라져, 해석이 불안정해진다.

추가로, 구현 관점에서 반드시 지켜야 할 안전 조건은 다음이다.

* (|\vec{v}| = 0)인 경우 normalization은 정의되지 않는다(0으로 나누기).
  따라서 실무에서는 “길이가 매우 작은 경우”에 대한 branch 또는 epsilon 처리가 필요하다.

---

### 5) 방향 vector를 그릴 때의 사고 방식(개념 실습)

여기서는 OpenGL로 복잡한 시각화를 만들기 전에, 사고 모델을 먼저 고정한다.

1. “어느 방향을 가리키는 화살표”는 unit vector로 표현한다.
2. “화살표를 얼마나 길게 그릴지”는 별도의 scalar로 곱해서 결정한다.

즉, 방향과 크기를 분리한다.

$$
\vec{arrow} = L \cdot \hat{d}
$$

* (\hat{d}): direction(unit)
* (L): length(scalar)

이 분리는 이후 lighting에서 “빛의 방향”과 “빛의 세기”를 분리해 사고하는 방식과 동일한 구조를 가진다.

---

### 6) 최소 실습(선택): console에서 length/normalize를 검증

본 소제목은 OpenGL 렌더링 코드가 필수는 아니다. 다만 수학 개념을 고정하기 위해, 다음과 같은 console 검증은 유효하다.

```cpp
// main.cpp
#include <cmath>
#include <iostream>

struct Vec2 {
    float x, y;
};

static float length(Vec2 v) {
    return std::sqrt(v.x*v.x + v.y*v.y);
}

static Vec2 normalize(Vec2 v) {
    float len = length(v);

    if (len == 0.0f) return {  0.0f, 0.0f  };
    else             return {  v.x / len, v.y / len  };
}

int main() {
    Vec2 v {  3.0f, 4.0f  };
    float len = length(v);
    Vec2 u = normalize(v);

    std::cout << "v=(" << v.x << ", " << v.y << ")" << std::endl;
    std::cout << "|v| = " << len << std::endl;
    std::cout << "u = normalize(v) = (" << u.x << ", " << u.y << ")" << std::endl;
    std::cout << "|u| = " << length(u) << std::endl;

    return 0;
}
```

이 출력에서 기대되는 수치적 성질은 다음이다.

* (|(3,4)| = 5)
* normalize 후 길이는 1에 매우 가깝다(부동소수 오차는 허용)
