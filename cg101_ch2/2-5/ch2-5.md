[OPENGL_CG101_PROGRESS] current_chapter=2, completed=[1], next_up=Chapter 2-5 (2D rotation formulas + atan2 angle read/write)

# CH2 — Vectors: dot/cross, directions, normals (No matrices yet)

## CH2-5. 2D 회전(삼각함수 기반) 공식과 atan2로 “각도 만들기/읽기”: 수식 정리 및 main.cpp 실습

### 1) 본 소제목의 학습 범위

본 소제목은 2D에서 “각도(angle)”와 “방향(direction vector)”를 상호 변환하는 최소 수학을 확립한다. OpenGL/GLSL과는 연계하지 않으며, `cmath`, `cstdio`만 사용한 단일 `main.cpp` 실습으로 공식을 검증한다. 다루는 항목은 다음으로 한정한다.

* 2D 회전 공식(삼각함수 기반)과 그 의미
* 각도 → 방향 벡터 생성(“angle 만들기”)
* 방향 벡터 → 각도 복원(“angle 읽기”)을 위한 `atan2`
* 각도 단위(radians vs degrees) 및 범위(normalization) 규약

---

### 2) 2D 회전 공식(삼각함수 기반): 정의와 사용 형태

#### 2.1 회전의 정의(보고서식 서술)

2D 평면에서 원점(0,0)을 기준으로 vector (\vec{v}=(x,y))를 각도 (\theta)만큼 회전시킨 결과 (\vec{v}'=(x',y'))는 다음과 같이 정의된다.

[
\begin{pmatrix}
x' \
y'
\end{pmatrix}
=============

\begin{pmatrix}
\cos\theta & -\sin\theta \
\sin\theta & \cos\theta
\end{pmatrix}
\begin{pmatrix}
x \
y
\end{pmatrix}
]

이를 성분으로 전개하면 다음과 같이 사용된다.

[
x' = x\cos\theta - y\sin\theta,\quad
y' = x\sin\theta + y\cos\theta
]

이 식은 “회전”이라는 기하학적 변환을 삼각함수로 닫힌 형태로 표현한 것이다. 본 과정에서는 matrix를 CH3에서 정식 도입하므로, CH2-5에서는 위 식을 “공식”으로 사용하되, 의미는 다음 1문장으로 고정한다.

* 회전은 vector의 length를 보존하며, 방향만 각도 (\theta)만큼 변경하는 변환이다.

#### 2.2 각도 단위의 규약

`sin`, `cos`, `atan2`는 **radians**를 입력/출력 단위로 사용한다. 따라서 degrees를 사용하려면 변환이 필요하다.

[
\text{rad} = \text{deg}\cdot\frac{\pi}{180},\quad
\text{deg} = \text{rad}\cdot\frac{180}{\pi}
]

---

### 3) “각도 만들기”: angle → direction vector

2D에서 “방향”은 흔히 unit vector로 취급된다. 각도 (\theta)가 주어졌을 때, 그 방향을 가리키는 unit direction (\hat{d})는 다음으로 정의된다.

[
\hat{d}(\theta) = (\cos\theta,\ \sin\theta)
]

이 정의는 “원 위의 점”과 동일하며, 방향을 각도 하나로 압축 표현하는 표준적인 매핑이다.

---

### 4) “각도 읽기”: direction vector → angle via atan2

(\vec{v}=(x,y))가 주어졌을 때, 이 vector가 +x축을 기준으로 이루는 각도 (\theta)를 복원하는 가장 표준적인 함수가 `atan2`이다.

[
\theta = \operatorname{atan2}(y,\ x)
]

`atan2(y, x)`는 다음 성질을 갖는다.

* 사분면(quadrant)을 올바르게 판정한다.
  단순한 (\arctan(y/x))는 (x)의 부호에 의해 사분면이 뒤집히는 문제가 있으므로 일반적으로 사용하지 않는다.
* (x=0)인 경우도 안전하게 처리한다(정의가 분기되어 있음).
* 반환 범위는 보통 ((-\pi,\pi])로 취급된다(구현에 따라 경계 포함 여부는 표현 차이가 있을 수 있으나, 범위는 이 구간으로 보는 것이 표준적이다).

추가로, 입력 vector가 unit이 아니어도 `atan2`는 “방향”만 사용하므로 각도 복원에는 문제가 없다. 다만 ((0,0))은 방향이 정의되지 않으므로 각도 복원도 정의되지 않는다.

---

### 5) 각도 범위 정규화(angle normalization)의 필요성

회전이나 누적 각속도 같은 연산을 하면 각도가 (\theta = 100\pi)처럼 커질 수 있다. `sin/cos`는 주기 함수이므로 수학적으로는 동일하나, 수치적/표현적 일관성을 위해 보통 각도를 다음 중 하나의 범위로 정규화한다.

* ([0, 2\pi))
* ((-\pi, \pi])

본 실습에서는 ((-\pi, \pi])로 정규화하는 함수를 제공한다. 이는 `atan2`의 반환 범위와 정렬되므로 해석이 단순해진다.

---

## 6) main.cpp 실습 코드 (cmath + cstdio only)

아래 코드는 다음을 한 번에 검증한다.

1. 회전 공식으로 vector를 회전시키는 방법
2. `atan2`로 회전된 vector의 각도를 읽는 방법
3. angle → direction 생성 및 round-trip(angle → vector → angle) 확인
4. angle normalization의 필요성과 동작

```cpp
// main.cpp
#include <cmath>
#include <cstdio>

struct Vec2 {
    double x, y;
};

static double dot(Vec2 a, Vec2 b) {
    return a.x*b.x + a.y*b.y;
}

static double length(Vec2 v) {
    return std::sqrt(dot(v, v));
}

static Vec2 rotate(Vec2 v, double theta_rad) {
    // [x'] = [ cos -sin ][x]
    // [y']   [ sin  cos ][y]
    const double c = std::cos(theta_rad);
    const double s = std::sin(theta_rad);
    return {
        v.x * c - v.y * s,
        v.x * s + v.y * c
    };
}

static Vec2 dir_from_angle(double theta_rad) {
    // unit direction for given angle
    return { std::cos(theta_rad), std::sin(theta_rad) };
}

static double angle_from_dir(Vec2 v) {
    // returns angle in radians, typically in (-pi, pi]
    // undefined for (0,0); here we just return 0 for safety
    if (v.x == 0.0 && v.y == 0.0) return 0.0;
    return std::atan2(v.y, v.x);
}

static double deg_to_rad(double deg) {
    return deg * (3.14159265358979323846 / 180.0);
}

static double rad_to_deg(double rad) {
    return rad * (180.0 / 3.14159265358979323846);
}

static double normalize_angle_pi(double rad) {
    // Normalize to (-pi, pi]
    const double pi = 3.14159265358979323846;
    const double two_pi = 2.0 * pi;

    // Bring into (-2pi, 2pi) range first
    rad = std::fmod(rad, two_pi);

    // Then shift to (-pi, pi]
    if (rad <= -pi) rad += two_pi;
    if (rad >  pi)  rad -= two_pi;
    return rad;
}

int main() {
    std::printf("=== CH2-5: 2D rotation + atan2 (radians) ===\n\n");

    // (A) Rotate a non-unit vector and verify length preservation
    Vec2 v{3.0, 4.0};                  // length = 5
    double theta = deg_to_rad(30.0);   // rotate by 30 degrees

    Vec2 vr = rotate(v, theta);

    std::printf("[A] Rotate v=(%.6f, %.6f) by 30 deg\n", v.x, v.y);
    std::printf("    |v|  = %.6f\n", length(v));
    std::printf("    vr   = (%.6f, %.6f)\n", vr.x, vr.y);
    std::printf("    |vr| = %.6f  (should be close to |v|)\n\n", length(vr));

    // (B) Read angle from a direction vector using atan2
    // Use a clean direction generated from angle, then recover it
    double a0 = deg_to_rad(135.0);
    Vec2 d0 = dir_from_angle(a0);
    double a1 = angle_from_dir(d0);

    std::printf("[B] Angle -> dir -> angle (round-trip)\n");
    std::printf("    a0(deg)=%.3f\n", rad_to_deg(a0));
    std::printf("    d0     =(%.6f, %.6f)  (unit direction)\n", d0.x, d0.y);
    std::printf("    a1(deg)=%.3f  (atan2 result)\n\n", rad_to_deg(a1));

    // (C) Compose angles, then normalize to (-pi, pi]
    double big = deg_to_rad(135.0 + 720.0 + 30.0); // large angle
    double big_norm = normalize_angle_pi(big);

    std::printf("[C] Angle normalization\n");
    std::printf("    big(deg)     = %.3f\n", rad_to_deg(big));
    std::printf("    norm(deg)    = %.3f  (in (-180, 180])\n\n", rad_to_deg(big_norm));

    // (D) Read angle from a rotated direction
    Vec2 d = dir_from_angle(deg_to_rad(10.0));
    Vec2 dr = rotate(d, deg_to_rad(80.0)); // expect ~90 deg direction
    double ar = angle_from_dir(dr);

    std::printf("[D] Rotate direction and read angle\n");
    std::printf("    start dir angle(deg)=10.000\n");
    std::printf("    rotated dir         =(%.6f, %.6f)\n", dr.x, dr.y);
    std::printf("    atan2 angle(deg)    =%.3f (expected around 90 deg)\n\n", rad_to_deg(ar));

    return 0;
}
```

---

## 7) Common pitfalls 및 디버깅 포인트

* `sin/cos/atan2`가 radians 단위를 사용한다는 사실을 누락하면 모든 수치가 붕괴한다.
* `atan2(y,x)`의 인자 순서를 반대로 쓰면 각도가 다른 의미를 갖는다.
* ((0,0)) vector는 방향이 정의되지 않으므로 `atan2` 기반 각도 복원이 의미를 잃는다.
* 각도 누적(composition) 후 정규화를 수행하지 않으면, 로그/디버깅에서 각도가 불필요하게 커져 해석이 어려워진다.