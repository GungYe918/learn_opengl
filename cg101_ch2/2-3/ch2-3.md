# CH2 — Vectors: dot/cross, directions, normals (No matrices yet)

## CH2-3. cross product(외적): 법선(normal), 방향성(orientation), 면의 “앞/뒤”를 정의하는 기하학

### 1) 본 소제목의 학습 범위

본 소제목은 cross product(외적)을 통해 “면이 어떤 방향을 향하는지”를 수학적으로 정의하는 방법을 확립한다. 이는 graphics에서 normal vector, triangle orientation(winding), 그리고 이후 back-face culling 및 lighting의 전제가 된다. 본 소제목은 matrix 및 좌표계 변환을 포함하지 않는다. 다루는 항목은 다음으로 한정한다.

* 3D 외적의 대수적 정의와 기하학적 의미
* right-hand rule에 기반한 방향성(orientation)의 결정
* triangle의 normal 계산(두 edge의 외적)
* 2D에서의 “외적 유사량”(signed area 관점)의 최소 언급
* 수치적/구현적 함정(정규화, degeneracy)

---

### 2) cross product(외적)의 정의

#### 2.1 3D에서의 대수적 정의

(\vec{a} = (a_x,a_y,a_z)), (\vec{b} = (b_x,b_y,b_z))에 대해 외적은 3D vector로 정의된다.

$$
\vec{a}\times\vec{b} =
\begin{pmatrix}
a_y b_z - a_z b_y \
a_z b_x - a_x b_z \
a_x b_y - a_y b_x
\end{pmatrix}
$$

이 정의는 구현 관점에서 완전히 결정적이며, 실제 코드에서는 위 성분식을 그대로 계산한다.

#### 2.2 기하학적 정의: 수직성과 면적

외적은 다음 두 성질을 동시에 만족한다.

1. **수직성(orthogonality)**
   $$
   (\vec{a}\times\vec{b}) \cdot \vec{a} = 0,\quad
   (\vec{a}\times\vec{b}) \cdot \vec{b} = 0
   $$
   즉, (\vec{a}\times\vec{b})는 (\vec{a})와 (\vec{b})가 이루는 평면에 수직인 vector이다.

2. **크기(magnitude)의 의미: 평행사변형 면적**
   $$
   |\vec{a}\times\vec{b}| = |\vec{a}||\vec{b}|\sin\theta
   $$
   여기서 (\theta)는 (\vec{a})와 (\vec{b}) 사이의 각이다. 따라서 외적의 크기는 (\vec{a})와 (\vec{b})가 만드는 평행사변형의 면적과 일치한다.

이 두 성질 때문에 외적은 graphics에서 “면의 방향(법선)”과 “면적 성분”을 동시에 담는 도구로 사용된다. 조명 계산에서 필요한 것은 보통 방향이므로, 외적 결과를 normalization하여 unit normal로 사용한다.

---

### 3) right-hand rule과 orientation(방향성)

외적은 교환법칙을 만족하지 않으며, 다음이 성립한다.

$$
\vec{a}\times\vec{b} = -(\vec{b}\times\vec{a})
$$

즉, 입력 순서를 바꾸면 결과가 정확히 반대로 뒤집힌다. 이 “순서 의존성”이 곧 triangle의 앞/뒤(front/back) 정의의 핵심이며, 이를 기하학적으로 결정하는 규칙이 **right-hand rule**이다.

* 오른손의 검지 방향을 (\vec{a}), 중지 방향을 (\vec{b})로 두면, 엄지가 (\vec{a}\times\vec{b})의 방향을 가리킨다.

이 규칙은 “면이 어느 쪽을 향한다”를 안정적으로 정의하게 해준다. 같은 세 점으로 만든 triangle이라도 vertex ordering(winding)이 바뀌면 법선 방향이 반대로 바뀐다.

---

### 4) triangle normal 계산: 두 edge의 외적

triangle의 세 vertex를 (P_0, P_1, P_2)라 하자. triangle의 두 edge를 다음과 같이 정의한다.

$$
\vec{e_1} = P_1 - P_0,\quad
\vec{e_2} = P_2 - P_0
$$

그러면 triangle normal(정확히는 면에 수직인 vector)은

$$
\vec{n} = \vec{e_1} \times \vec{e_2}
$$

조명 계산 등에 사용할 unit normal은

$$
\hat{n} = \frac{\vec{n}}{|\vec{n}|}
$$

으로 정의된다(단, (|\vec{n}|\neq 0)).

여기서 (|\vec{n}|=0)이 되는 경우는 triangle이 degeneracy(세 점이 일직선이거나, 두 점이 동일하여 면적이 0)인 경우이며, 이때 normal은 정의상 불안정하다. 실무에서는 epsilon 기반의 guard가 필요하다.

---

### 5) 2D에서의 “외적 유사량”: signed area와 회전 방향

2D vector는 3D 외적을 직접 정의하지 않지만, 다음 스칼라 값은 2D에서 외적의 방향성 역할을 한다.

$$
\text{cross2}(a,b) = a_x b_y - a_y b_x
$$

이 값은 기하학적으로 “signed area(부호 있는 면적)”에 대응하며, 부호는 회전 방향을 나타낸다.

* (\text{cross2}(a,b) > 0): (a \to b)가 반시계(CCW) 회전 성분을 갖는다
* (\text{cross2}(a,b) < 0): (a \to b)가 시계(CW) 회전 성분을 갖는다
* (\text{cross2}(a,b) = 0): collinear(일직선)

이 개념은 polygon winding 판정, 2D 기하(충돌/클리핑)에서 핵심적으로 재사용된다.

---

### 6) 실습용 코드: console에서 triangle normal 검증

```cpp
// main.cpp
#include <cmath>
#include <cstdio>

struct Vec3 {
    float x, y, z;
};

static Vec3 sub(Vec3 a, Vec3 b) {
    return {a.x-b.x, a.y-b.y, a.z-b.z}; 
}

static float dot(Vec3 a, Vec3 b) {
    return a.x*b.x + a.y*b.y + a.z*b.z;
}

static Vec3 cross(Vec3 a, Vec3 b) {
    return {
        a.y*b.z - a.z*b.y,
        a.z*b.x - a.x*b.z,
        a.x*b.y - a.y*b.x
    };
}

static float length(Vec3 v) {
    return std::sqrt(dot(v, v));
}

static Vec3 normalize(Vec3 v) {
    float len = length(v);
    if (len == 0) return { 0.0f, 0.0f, 0.0f };
    else          return { v.x/len, v.y/len, v.z/len }; 
}

int main() {
    Vec3 P0 {0.0f, 0.0f, 0.0f };
    Vec3 P1 {1.0f, 0.0f, 0.0f };
    Vec3 P2 {0.0f, 1.0f, 0.0f };

    Vec3 e1 = sub(P1, P0);
    Vec3 e2 = sub(P2, P0);

    Vec3 n  = cross(e1, e2);
    Vec3 nh = normalize(n);

    std::printf("n  = (%.3f, %.3f, %.3f), |n|  = %.3f\n", n.x, n.y, n.z,    length(n));
    std::printf("nh = (%.3f, %.3f, %.3f), |nh| = %.3f\n", nh.x, nh.y, nh.z, length(nh));

    std::printf("dot(n, e1) = %.3f\n", dot(n, e1));
    std::printf("dot(n, e2) = %.3f\n", dot(n, e2));

    return 0;
}
```

이 예시에서 기대되는 성질은 다음과 같다.

* (P_0=(0,0,0), P_1=(1,0,0), P_2=(0,1,0))는 (xy)-평면 위의 triangle이며
  (\vec{e_1}=(1,0,0)), (\vec{e_2}=(0,1,0)) 이고
  (\vec{e_1}\times\vec{e_2}=(0,0,1)) 방향의 normal이 생성된다.
* `dot(n, e1)`과 `dot(n, e2)`는 0에 가까워야 하며, 이는 수직성을 수치로 확인하는 절차이다.
* vertex 순서를 바꾸어 (\vec{e_2}\times\vec{e_1})을 계산하면 결과가 ((0,0,-1))로 반전되어 orientation 의존성이 확인된다.

---

### 7) Common pitfalls 및 디버깅 포인트

1. **입력 순서 혼동(winding mismatch)**

* (\vec{e_1}\times\vec{e_2})와 (\vec{e_2}\times\vec{e_1})은 부호가 반대다.
* triangle normal이 반대로 나오면, “수학이 틀린 것”이 아니라 “정의한 방향성이 바뀐 것”이다.

2. **degenerate triangle 처리 부재**

* (|\vec{e_1}\times\vec{e_2}| = 0)이면 normal은 정의상 불안정하며 normalization이 실패한다.
* 모델 데이터 또는 동적 생성 과정에서는 이 케이스가 실제로 발생한다.

3. **정규화 누락**

* 외적 결과는 면적 성분을 포함하므로 길이가 1이 아니다.
* 조명 계산에 “각도 성분”으로 쓰려면 unit normal이 필요하며, normalization이 필수이다.

4. **“법선은 점이다”라는 오해**

* normal은 위치가 아니라 direction vector이다.
* 따라서 평행이동(translation)의 의미와 분리된 데이터로 취급되어야 한다(정식 변환 문제는 CH7/CH4 이후에 엄밀화).